/*
  _____ _ _ _                    _             _       
 |  ___(_) | |_ ___ _ __   _ __ | |_   _  __ _(_)_ __  
 | |_  | | | __/ _ \ '__| | '_ \| | | | |/ _` | | '_ \ 
 |  _| | | | ||  __/ |    | |_) | | |_| | (_| | | | | |
 |_|   |_|_|\__\___|_|    | .__/|_|\__,_|\__, |_|_| |_|
                          |_|            |___/         
# A Template for Pose_estimationPlugin, a Filter Plugin
# Generated by the command: plugin -t filter -d pose_estimation_plugin pose_estimation
# Hostname: MacBook-Air-di-Alberto-6.local
# Current working directory: /Users/alberto/MECHATRONIC_ENGINEERING/ROBOTIC_PERCEPTION/PROJECT/PLUGIN
# Creation date: 2025-11-28T17:25:29.889+0100
# NOTICE: MADS Version 1.4.0
*/
// Mandatory included headers

#include <Eigen/Dense>          // N.B.: brew install eigen, then add in .vscode the header for this lib
#include <cmath>
#include <iostream>
#include <filter.hpp>
#include <nlohmann/json.hpp>
#include <pugg/Kernel.h>

// Define the name of the plugin
#ifndef PLUGIN_NAME
#define PLUGIN_NAME "pose_estimation"
#endif

#define PRINT_INPUT 0
#define PRINT_OUTPUT 0
#define REAL_TIME 0       // 1 for real-time operation, 0 for offline processing

// Load the namespaces
using namespace std;
using json = nlohmann::json;


// Static variables to keep track of sensors values and time
static bool first = false;
static bool second = false;
static int last_enc_L = 0;
static int last_enc_R = 0;
static double last_time = 0.0;
bool ekf_first_init = true;
bool rs_valid = true;         // realsense validity, true for use in EKF
bool use_imu = true;          // use imu yaw in EKF update
bool first_imu = true;         
static float prev_w_z = 0.0;
static double x_dot_MO = 0.0;
static double y_dot_MO = 0.0;
static double z_dot_MO = 0.0;


// _________________________________________ CLASSES ______________________________________________

// Define a class to store ENCODER data
class EncoderData {
public:
  int left_encoder;
  int right_encoder;
  double timecode;
  EncoderData() : left_encoder(0), right_encoder(0), timecode(0.0) {}
};

// Define a class to store HTC data
class HTCData {
public:
  float x;
  float y;
  float z;
  double timecode;
  HTCData() : x(0.0), y(0.0), z(0.0), timecode(0.0) {}
};

// Define a class to store REALSENSE data
class RealsenseData{
public:
  float x;
  float y;
  float z;
  double theta;
  double timecode;
  RealsenseData() : x(0.0), y(0.0), z(0.0), theta(0.0), timecode(0.0) {}
};

// Define a class to store IMU data
class IMUData{
public:
  float acc_x;
  float acc_y;
  float acc_z;
  float gyro_x;
  float gyro_y;
  float gyro_z;
  double fusion_roll;
  double fusion_pitch;
  double fusion_yaw;
  double timecode;
  IMUData() : acc_x(0.0), acc_y(0.0), acc_z(0.0), gyro_x(0.0), gyro_y(0.0), gyro_z(0.0), fusion_roll(0.0), fusion_pitch(0.0), fusion_yaw(0.0), timecode(0.0) {}
};

// Define a class to store POSE data
class PoseData {
public:
  double x;
  double y;
  double z;
  double theta;
  double timecode;
  PoseData() : x(0.0), y(0.0), z(0.0), theta(0.0), timecode(0.0) {}
};


class ExtendedKalmanFilter {
public:
    ExtendedKalmanFilter(double R_L, double R_R, double wheel_base, int ticks_per_rev)
        : R_L_(R_L), R_R_(R_R), b_(wheel_base), n0_(ticks_per_rev) {
        
        // State: [x, y, theta]
        x_.setZero();
        
        // Covariance P
        P_.setIdentity();
        P_ *= 0.1;        

        initialized_ = false;
    }

    void init(double x0, double y0, double theta0, double t0) {
        x_(0) = x0; x_(1) = y0; x_(2) = theta0;
        t_last_ = t0;
        initialized_ = true;
    }

    // Tuning method to update Q and R matrices
    void set_tuning(double q_pos, double q_yaw, double r_imu, double r_rs_pos, double r_rs_yaw) {
        // Aggiorna Q (Incertezza modello/encoder)
        Q_.setZero();
        Q_(0,0) = q_pos; 
        Q_(1,1) = q_pos;
        Q_(2,2) = q_yaw;

        // Aggiorna R IMU
        R_imu_.setZero();
        R_imu_(0,0) = r_imu; 

        // Aggiorna R Realsense
        R_rs_.setZero();
        R_rs_(0,0) = r_rs_pos; 
        R_rs_(1,1) = r_rs_pos;
        R_rs_(2,2) = r_rs_yaw;
        
        // cout << "[EKF Tuning] Matrici aggiornate" << endl;
    }

    // STATE PREDICTION (usando Encoders come Input di controllo)
    void predict(double t_now, int nL, int nR) {
        double dt = t_now - t_last_;
        if (dt <= 0.0001) return; // Evita divisioni per zero o dt negativi

        // 1. Calcolo input di controllo (v, w) dagli encoder
        // Calcolo spostamento lineare (ds) e angolare (dtheta) in questo dt
        double d_left  = (2.0 * M_PI * R_L_ * nL) / n0_;
        double d_right = (2.0 * M_PI * R_R_ * nR) / n0_;
        
        double ds = (d_right + d_left) / 2.0;
        double dtheta = (d_right - d_left) / b_;

        double theta = x_(2);

        // 2. Aggiornamento dello Stato (Modello Uniciclo)
        // x_k+1 = x_k + ds * cos(theta + dtheta/2)
        // y_k+1 = y_k + ds * sin(theta + dtheta/2)  <-- Runge-Kutta 2nd order approx per l'angolo
        // th_k+1 = th_k + dtheta
        
        double avg_theta = theta + dtheta / 2.0;
        
        x_(0) = x_(0) + ds * std::cos(avg_theta);
        x_(1) = x_(1) + ds * std::sin(avg_theta);
        x_(2) = x_(2) + dtheta;

        // Normalizzazione angolo tra -PI e PI
        x_(2) = std::atan2(std::sin(x_(2)), std::cos(x_(2)));

        // 3. Aggiornamento Covarianza P = F*P*F' + Q
        // Jacobiano F rispetto a [x, y, theta]
        Eigen::Matrix3d F;
        F.setIdentity();
        // Derivate parziali rispetto a theta
        F(0, 2) = -ds * std::sin(avg_theta);
        F(1, 2) =  ds * std::cos(avg_theta);

        P_ = F * P_ * F.transpose() + Q_;

        t_last_ = t_now;
    }

    // UPDATE STEP: Realsense (Posizione + Theta)
    void update_realsense(double rs_x, double rs_y, double rs_theta) {
        // Misura z
        Eigen::Vector3d z;
        z << rs_x, rs_y, rs_theta;

        // Modello misura H (identità, perché misuriamo direttamente lo stato)
        Eigen::Matrix3d H = Eigen::Matrix3d::Identity();

        // Residuo y = z - Hx
        Eigen::Vector3d y = z - x_;
        y(2) = std::atan2(std::sin(y(2)), std::cos(y(2))); // Normalizza angolo

        // Calcolo Kalman Gain
        Eigen::Matrix3d S = H * P_ * H.transpose() + R_rs_;
        Eigen::Matrix3d K = P_ * H.transpose() * S.inverse();

        // Update stato e covarianza
        x_ = x_ + K * y;
        P_ = (Eigen::Matrix3d::Identity() - K * H) * P_;
        
        // Normalizza angolo finale
        x_(2) = std::atan2(std::sin(x_(2)), std::cos(x_(2)));
    }

    // UPDATE STEP: IMU (Solo Yaw)
    void update_imu(double imu_yaw) {
        // Misura scalare z
        double z = -(imu_yaw + M_PI);       // TODO: verify why double z = -(imu_yaw + M_PI);
        
        // H matrix: mappa lo stato [x,y,th] alla misura [th] -> [0, 0, 1]
        Eigen::RowVector3d H;
        H << 0, 0, 1;

        double y_res = z - x_(2);
        y_res = std::atan2(std::sin(y_res), std::cos(y_res)); // Normalizza

        double S = (H * P_ * H.transpose())(0,0) + R_imu_(0,0);
        Eigen::Vector3d K = P_ * H.transpose() / S;

        x_ = x_ + K * y_res;
        P_ = (Eigen::Matrix3d::Identity() - K * H) * P_;
        
        x_(2) = std::atan2(std::sin(x_(2)), std::cos(x_(2))); 
    }

    Eigen::Vector3d getState() const { return x_; }

private:
    Eigen::Vector3d x_; // State [x, y, theta]
    Eigen::Matrix3d P_; // Covariance
    Eigen::Matrix3d Q_; // Process Noise
    Eigen::Matrix3d R_rs_; // Realsense Noise
    Eigen::Matrix3d R_imu_; // IMU Noise (only yaw)

    double R_L_, R_R_, b_;
    int n0_;
    bool initialized_;
    double t_last_;
};






// _______________________________________________________________________________________________


// Plugin class. This shall be the only part that needs to be modified,
// implementing the actual functionality
class Pose_estimationPlugin : public Filter<json, json> {

public:

  string kind() override { return PLUGIN_NAME; }

  return_type load_data(json const &input, string topic = "") override {

    // Store data from encoders
    if (topic == "encoders") {
      printf("Storing encoder data...\n");
      const auto &root = REAL_TIME ? input : input["message"];
      if (root.contains("encoders")) {
        const auto &E = root["encoders"];
        if (E.contains("left") && E["left"].is_number()) {
          encoder_data.left_encoder = E["left"].get<int>();
          if (!second) {
            first = true;
          }
        }
        if (E.contains("right") && E["right"].is_number()) {
          encoder_data.right_encoder = E["right"].get<int>();
        }
      }
      if (root.contains("timecode") && root["timecode"].is_number()) {
        encoder_data.timecode = root["timecode"].get<double>();
      }
    }

    // Store data from HTC (position is a vector with x,y,z)
    if (topic == "htc") {
      printf("Storing HTC data...\n");
      const auto &root = REAL_TIME ? input : input["message"];
      if (root.contains("pose") && root["pose"].contains("position")) {
        const auto &P = root["pose"]["position"];
        if (P.is_array() && P.size() >= 3) {

          if (P[0].is_number()) {
            htc_data.x = P[0].get<float>();
          }
          if (P[1].is_number()) {
            htc_data.y = P[1].get<float>();
          }
          if (P[2].is_number()) {
            htc_data.z = P[2].get<float>();
          }
        }
      }
      if (root.contains("timecode") && root["timecode"].is_number()) {
        htc_data.timecode = root["timecode"].get<double>();
      }
    }

    // Store data from Realsense
    if (topic == "H_initial_walker_aruco") {
      const auto &root = REAL_TIME ? input : input["message"];
      if (root.contains("pose") && root["pose"].contains("position")) {
        const auto &P = root["pose"]["position"];
        if (P.is_array() && P.size() >= 3) {
          if (P[0].is_number())
            realsense_data.x = P[0].get<float>(); //+ 0.2245;
          if (P[1].is_number())
            realsense_data.y = P[1].get<float>(); //- 0.1744;
          if (P[2].is_number())
            realsense_data.z = P[2].get<float>();
        }
      }
      if (root.contains("pose") && root["pose"].contains("attitude")) {
        const auto &A = root["pose"]["attitude"];
        if (A.is_array() && A.size() >= 3) {
          if (A[2].is_number()) {
            realsense_data.theta = A[2].get<float>();
          }
        }
      }
      if (root.contains("timecode") && root["timecode"].is_number()) {
        realsense_data.timecode = root["timecode"].get<double>();
      }
    }

    // Store data from IMU
    if (topic == "imu") {
      const auto &root = REAL_TIME ? input : input["message"];
      if (root.contains("accel")) {
        const auto &A = root["accel"];
        if (A.is_array() && A.size() >= 3) {
          if (A[0].is_number())
            imu_data.acc_x = A[0].get<float>(); // - a_x_off_imu; // g

          if (A[1].is_number())
            imu_data.acc_y = A[1].get<float>(); // - a_y_off_imu;

          if (A[2].is_number())
            imu_data.acc_z = A[2].get<float>();
        }
      }
      if (root.contains("gyro")) {
        const auto &G = root["gyro"];
        if (G.is_array() && G.size() >= 3) {
          if (G[0].is_number())
            imu_data.gyro_x = G[0].get<float>(); // rad/s
          if (G[1].is_number())
            imu_data.gyro_y = G[1].get<float>();
          if (G[2].is_number())
            imu_data.gyro_z = G[2].get<float>(); // - w_z_off_imu; // Z axis inverted
        }
      }
      if (root.contains("fusionPose")) {
        const auto &F = root["fusionPose"];
        if (F.is_array() && F.size() >= 3) {
          if (F[0].is_number())
            imu_data.fusion_roll = F[0].get<double>(); // rad
          if (F[1].is_number())
            imu_data.fusion_pitch = F[1].get<double>();
          if (F[2].is_number())
            imu_data.fusion_yaw = F[2].get<double>();
        }
      }
      if (root.contains("timecode") && root["timecode"].is_number()) {
        imu_data.timecode = root["timecode"].get<double>();
      }
    }

    if (PRINT_INPUT) {
      // cout << "\n\n___________ Input data: ____________\n\n" << input.dump(2) << endl;
      cout << "\n\n___________ Stored data: ____________\n\n";
      cout << "Encoders: Left = " << encoder_data.left_encoder
           << ", Right = " << encoder_data.right_encoder << endl;
      cout << "HTC Position: x = " << htc_data.x << ", y = " << htc_data.y
           << ", z = " << htc_data.z << endl;
      cout << "Realsense Position: x = " << realsense_data.x
           << ", y = " << realsense_data.y << ", z = " << realsense_data.z
           << endl;
      cout << "IMU Accel: x = " << imu_data.acc_x << ", y = " << imu_data.acc_y
           << ", z = " << imu_data.acc_z << endl;
      cout << "Timecode: " << encoder_data.timecode << endl;
    }

    return return_type::success;
  }


  return_type process(json &out) override {
    
    // Gestione inizializzazione tempi ed encoder precedenti
    if (first) {
      last_enc_L = encoder_data.left_encoder;
      last_enc_R = encoder_data.right_encoder;
      last_time = encoder_data.timecode;
      second = true;
      first = false;
      
      // Inizializza l'EKF con la prima posizione nota (es. 0 o da Realsense se disponibile)
      ekf_ptr->init(0.0, 0.0, 0.0, encoder_data.timecode);
      cout << "EKF Initialized" << endl;
      return return_type::success; // Salta il primo ciclo per sicurezza
    }

    // 1. Calcolo delta ticks
    int n_Lk = encoder_data.left_encoder - last_enc_L;
    int n_Rk = encoder_data.right_encoder - last_enc_R;

    // Aggiorna variabili statiche per il prossimo ciclo
    last_enc_L = encoder_data.left_encoder;
    last_enc_R = encoder_data.right_encoder;

    // --- STEP 1: PREDICTION (Cinematica Encoder) ---
    // Passiamo i tick crudi e il tempo attuale. L'EKF calcola v, omega e sposta lo stato.
    float dt = encoder_data.timecode - last_time;
    last_time = encoder_data.timecode;
    ekf_ptr->predict(encoder_data.timecode, n_Lk, n_Rk);

    // --- STEP 2: UPDATE (Correzioni) ---
    
    // A. Update IMU (Corregge solo l'angolo Theta)
    // Usa fusion_yaw che è già filtrato internamente dall'IMU (di solito molto buono)
    // Nota: Assicurati che fusion_yaw sia nello stesso frame (zero allo start) o gestisci l'offset.
    if (use_imu) {
        ekf_ptr->update_imu(imu_data.fusion_yaw);
    }

    // B. Update Realsense (Corregge X, Y, Theta)
    if (rs_valid) { // rs_valid dovrebbe essere true se i dati RS sono freschi e affidabili
        ekf_ptr->update_realsense(
            realsense_data.x, 
            realsense_data.y, 
            realsense_data.theta
        );
    }

    // --- RECUPERO OUTPUT ---
    Eigen::Vector3d x_est = ekf_ptr->getState();
    pose_data_ekf.x = x_est(0);
    pose_data_ekf.y = x_est(1);
    pose_data_ekf.theta = x_est(2);
    pose_data_ekf.z = 0.0; 

    // Costruzione JSON di output (simile al tuo codice originale)
    
    // 1 _______ ELABORATE HTC DATA TO GET POSE ESTIMATE _______

    pose_data_htc.x = htc_data.x;
    pose_data_htc.y = htc_data.y;
    pose_data_htc.z = 0.0;          // assuming z=0 for HTC
    pose_data_htc.timecode = htc_data.timecode;

    pose_data_realsense.x = realsense_data.x;
    pose_data_realsense.y = realsense_data.y;
    pose_data_realsense.z = 0.0;    // assuming z=0 for realsense
    pose_data_realsense.timecode = realsense_data.timecode;

    // --- CALCOLO ODOMETRIA PURA (Solo per visualizzazione divergenza) ---
    // Calcolo spostamenti incrementali
    double ds_enc = M_PI * (n_Rk * R_R + n_Lk * R_L) / n0;
    double dtheta_enc = 2.0 * M_PI * (n_Rk * R_R - n_Lk * R_L) / (n0 * b);

    // Integrazione della posa (usando l'angolo medio per precisione)
    double avg_th = pose_data_enc.theta + dtheta_enc / 2.0;
    pose_data_enc.x += ds_enc * std::cos(avg_th);
    pose_data_enc.y += ds_enc * std::sin(avg_th);
    pose_data_enc.theta += dtheta_enc;

    // Normalizzazione angolo
    pose_data_enc.theta = std::atan2(std::sin(pose_data_enc.theta), std::cos(pose_data_enc.theta));
    pose_data_enc.timecode = encoder_data.timecode;



    if (!first_imu) { // Assicurati di avere un dt valido
      // 1. Ruota l'accelerazione lineare dal frame Rover al frame World usando lo Yaw
      float yaw_imu = imu_data.fusion_yaw;
      
      // Usiamo l'accelerazione lungo l'asse X del rover (avanti) 
      // Nota: imu_data.acc_x è già depurata dal bias nel tuo load_data
      double acc_x_world = (imu_data.acc_x * 9.81) * std::cos(yaw_imu);
      double acc_y_world = (imu_data.acc_x * 9.81) * std::sin(yaw_imu);

      // 2. Prima integrazione: Accelerazione -> Velocità
      x_dot_IMU += acc_x_world * dt;
      y_dot_IMU += acc_y_world * dt;

      // 3. Seconda integrazione: Velocità -> Posizione
      pose_data_imu.x += x_dot_IMU * dt;
      pose_data_imu.y += y_dot_IMU * dt;
      pose_data_imu.theta = yaw_imu;
      pose_data_imu.timecode = imu_data.timecode;
    }
    first_imu = false;




    // 5 _______ CONSTRUCT OUTPUT _______ 

    out.clear();
    // output from input data 
    out["encoders"] = {
      {"left", encoder_data.left_encoder},
      {"right", encoder_data.right_encoder}
    };
    out["htc"] = {htc_data.x, htc_data.y, htc_data.z};
    out["realsense"] = {realsense_data.x, realsense_data.y, realsense_data.z};
    out["imu"] = {imu_data.acc_x, imu_data.acc_y, imu_data.acc_z};
    // output from data elaboration
    out["position_enc"] = {pose_data_enc.x, pose_data_enc.y, pose_data_enc.z};
    out["position_htc"] = {pose_data_htc.x, pose_data_htc.y, pose_data_htc.z};
    out["position_realsense"] = {pose_data_realsense.x, pose_data_realsense.y, pose_data_realsense.z};
    out["position_imu"] = {pose_data_imu.x*0, pose_data_imu.y*0, pose_data_imu.z};
    out["position_ekf"] = {pose_data_ekf.x, pose_data_ekf.y, pose_data_ekf.z}; //{(pose_data_realsense.x - pose_data_enc.x)/2, (pose_data_realsense.y - pose_data_enc.y)/2, (pose_data_realsense.z - pose_data_enc.z)/2};
    out["attitude_ekf"] = pose_data_ekf.theta;
    //out["velocity_ekf"] = xekf(3);



    // 6 _______ PRINT FOR DEBUG ___________
    if (PRINT_OUTPUT){
      //cout << "\n\n___________ Output data: ____________\n\n" << out.dump(2) << endl;
      cout << "\n\n___________ Computed Pose Data: ____________\n\n";
      cout << "Encoder-based Pose: x = " << pose_data_enc.x << ", y = " << pose_data_enc.y << ", z = " << pose_data_enc.z << ", theta = " << pose_data_enc.theta << ", timecode = " << pose_data_enc.timecode << endl;
      cout << "HTC Pose: x = " << pose_data_htc.x << ", y = " << pose_data_htc.y << ", z = " << pose_data_htc.z << ", theta = " << pose_data_htc.theta << ", timecode = " << pose_data_htc.timecode << endl;
      cout << "Realsense Pose: x = " << pose_data_realsense.x << ", y = " << pose_data_realsense.y << ", z = " << pose_data_realsense.z << ", theta = " << pose_data_realsense.theta << ", timecode = " << pose_data_realsense.timecode << endl;
      cout << "IMU Pose: x = " << pose_data_imu.x << ", y = " << pose_data_imu.y << ", z = " << pose_data_imu.z << ", theta = " << pose_data_imu.theta << ", timecode = " << pose_data_imu.timecode << endl;
      //cout << "Time difference dt = " << dt << " seconds" << endl;
      //cout << "dx = " << dx << ", dy = " << dy << ", dtheta = " << dtheta << endl;
    }
    
    return return_type::success;
  }
  
  void set_params(void const *params) override {
    
    Filter::set_params(params);
    _params.merge_patch(*(json *)params);

    // 1.A. PHYSICAL PARAMETERS
    R_L = _params["R_L"];
    R_R = _params["R_R"];
    n0 = _params["n0"];
    b = _params["b"];

    // 1.B. SENSOR OFFSETS (from calibration)
    a_x_off_imu = _params["a_x_off_imu"];
    a_y_off_imu = _params["a_y_off_imu"];
    w_z_off_imu = _params["w_z_off_imu"];

    // 1:C. EKF TUNING PARAMETERS
    double q_p = _params["q_pos"];          // process noise for position
    double q_y = _params["q_yaw"];          // process noise for yaw
    double r_i = _params["r_imu_yaw"];      // measurement noise for IMU yaw
    double r_rp = _params["r_rs_pos"];     // measurement noise for Realsense position
    double r_ry = _params["r_rs_yaw"];     // measurement noise for Realsense yaw

    // 2. EKF INITIALIZATION
    ekf_ptr = std::make_unique<ExtendedKalmanFilter>(R_L, R_R, b, n0);
    if (ekf_first_init) {
      ekf_ptr->init(0.0, 0.0, 0.0, encoder_data.timecode); // Partiamo da 0
      ekf_first_init = false;
    }

    // 3. EKF TUNING (da calibrare empiricamente)
    ekf_ptr->set_tuning(q_p, q_y, r_i, r_rp, r_ry);

  }

  // Implement this method if you want to provide additional information
  map<string, string> info() override { 
    // return a map of strings with additional information about the plugin
    // it is used to print the information about the plugin when it is loaded
    // by the agent
    
    return {};
    
  };

private:
  // offsets
  double a_x_off_imu, a_y_off_imu, w_z_off_imu;
  
  // kinematic parameters
  double R_L;       // raggio ruota sinistra [m]
  double R_R;       // raggio ruota destra [m]
  int n0;           // tics per giro
  double b;         // distanza tra ruote [m]

  // Data in input from sensors
  EncoderData encoder_data;
  HTCData htc_data;
  RealsenseData realsense_data;
  IMUData imu_data;

  // smart pointer to EKF
  std::unique_ptr<ExtendedKalmanFilter> ekf_ptr;

  // Position computed by filter
  PoseData pose_data_enc;
  PoseData pose_data_htc;
  PoseData pose_data_realsense;
  PoseData pose_data_imu;
  PoseData pose_data_ekf;

  // Variabili di stato interne plugin
  int last_enc_L = 0;
  int last_enc_R = 0;
  double last_time = 0.0;
  bool ekf_first_init = true;

  // Se non sono già presenti nei membri privati della classe:
  double x_dot_IMU = 0.0;
  double y_dot_IMU = 0.0;
  // pose_data_imu è già dichiarata tra i tuoi membri privati
};


/*
  ____  _             _             _      _
 |  _ \| |_   _  __ _(_)_ __     __| |_ __(_)_   _____ _ __
 | |_) | | | | |/ _` | | '_ \   / _` | '__| \ \ / / _ \ '__|
 |  __/| | |_| | (_| | | | | | | (_| | |  | |\ V /  __/ |
 |_|   |_|\__,_|\__, |_|_| |_|  \__,_|_|  |_| \_/ \___|_|
                |___/
Enable the class as plugin
*/
INSTALL_FILTER_DRIVER(Pose_estimationPlugin, json, json);


/*
                  _       
  _ __ ___   __ _(_)_ __  
 | '_ ` _ \ / _` | | '_ \ 
 | | | | | | (_| | | | | |
 |_| |_| |_|\__,_|_|_| |_|
                          
*/

int main(int argc, char const *argv[])
{
  Pose_estimationPlugin plugin;
  json params;
  json input, output;

  // Set example values to params
  params["test"] = "value";


  // Set the parameters
  plugin.set_params(&params);

  // Set input data
  input["data"] = {
    {"AX", 1},
    {"AY", 2},
    {"AZ", 3}
  };

  // Set input data
  plugin.load_data(input);
  cout << "Input: " << input.dump(2) << endl;

  // Process data
  plugin.process(output);
  cout << "Output: " << output.dump(2) << endl;


  return 0;
}

