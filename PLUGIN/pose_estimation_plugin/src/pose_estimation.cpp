/*
  _____ _ _ _                    _             _       
 |  ___(_) | |_ ___ _ __   _ __ | |_   _  __ _(_)_ __  
 | |_  | | | __/ _ \ '__| | '_ \| | | | |/ _` | | '_ \ 
 |  _| | | | ||  __/ |    | |_) | | |_| | (_| | | | | |
 |_|   |_|_|\__\___|_|    | .__/|_|\__,_|\__, |_|_| |_|
                          |_|            |___/         
# A Template for Pose_estimationPlugin, a Filter Plugin
# Generated by the command: plugin -t filter -d pose_estimation_plugin pose_estimation
# Hostname: MacBook-Air-di-Alberto-6.local
# Current working directory: /Users/alberto/MECHATRONIC_ENGINEERING/ROBOTIC_PERCEPTION/PROJECT/PLUGIN
# Creation date: 2025-11-28T17:25:29.889+0100
# NOTICE: MADS Version 1.4.0
*/
// Mandatory included headers

#include <Eigen/Dense>          // N.B.: brew install eigen, then add in .vscode the header for this lib
#include <cmath>
#include <iostream>
#include <filter.hpp>
#include <nlohmann/json.hpp>
#include <pugg/Kernel.h>

// Define the name of the plugin
#ifndef PLUGIN_NAME
#define PLUGIN_NAME "pose_estimation"
#endif

#define PRINT_INPUT 0
#define PRINT_OUTPUT 1

// Load the namespaces
using namespace std;
using json = nlohmann::json;


// Static variables to keep track of last encoder values and time
static bool first = false;
static bool second = false;
static int last_enc_L = 0;
static int last_enc_R = 0;
static double last_time = 0.0;
bool ekf_first_init = true;

// _________________________________________ CLASSES ______________________________________________

// Define a class to store data from encoder
class EncoderData {
public:
  int left_encoder;
  int right_encoder;
  double timecode;
  EncoderData() : left_encoder(0), right_encoder(0), timecode(0.0) {}
};

// Define a class to store data from htc
class HTCData {
public:
  float x;
  float y;
  float z;
  double timecode;
  HTCData() : x(0.0), y(0.0), z(0.0), timecode(0.0) {}
};

// Define a class to store realsense data
class RealsenseData{
public:
  float x;
  float y;
  float z;
  double theta;
  double timecode;
  RealsenseData() : x(0.0), y(0.0), z(0.0), theta(0.0), timecode(0.0) {}
};

class IMUData{
public:
  float x;
  float y;
  float z;
  float acc_x;
  float acc_y;
  float acc_z;
  float gyro_x;
  float gyro_y;
  float gyro_z;
  double timecode;
  IMUData() : x(0.0), y(0.0), z(0.0), acc_x(0.0), acc_y(0.0), acc_z(0.0), gyro_x(0.0), gyro_y(0.0), gyro_z(0.0), timecode(0.0) {}
};

// Define a class to store pose data
class PoseData {
public:
  double x;
  double y;
  double z;
  double theta;
  double timecode;
  PoseData() : x(0.0), y(0.0), z(0.0), theta(0.0), timecode(0.0) {}
};

class ExtendedKalmanFilter {
public:
  // costruttore con parametri cinematica
  ExtendedKalmanFilter(double R_L, double R_R, double wheel_base, int ticks_per_rev)
  : R_L_(R_L), R_R_(R_R), b_(wheel_base), n0_(ticks_per_rev)
  {
    // stato iniziale [x,y,theta,v]
    x_.setZero(); // [0,0,0,0]
    // P iniziale come MATLAB
    P_ = Eigen::Matrix4d::Zero();
    P_(0,0) = 0.01; P_(1,1) = 0.01; P_(2,2) = 0.01; P_(3,3) = 0.1;

    // Q come MATLAB
    Q_ = Eigen::Matrix4d::Zero();
    Q_(0,0) = 0.02; Q_(1,1) = 0.02; Q_(2,2) = 0.01; Q_(3,3) = 0.1;

    // R enc (scalar on v) and R_rs (3x3) as MATLAB
    R_enc_ = 0.05; // scalar (MATLAB: diag(0.05))
    R_rs_ = Eigen::Matrix3d::Zero();
    R_rs_(0,0) = 0.02; R_rs_(1,1) = 0.02; R_rs_(2,2) = 0.01;

    initialized_ = false;
  }

  void init(double x0, double y0, double theta0, double v0, double t0) {
    x_(0) = x0; x_(1) = y0; x_(2) = theta0; x_(3) = v0;
    t_last_ = t0;
    initialized_ = true;
  }

  bool isInitialized() const { return initialized_; }

  // step: esegue prediction + encoder update + realsense update (se valido)
  // imu_accel_x: linear accel along forward axis (m/s^2)
  // imu_gyro_z: yaw rate (rad/s)
  // nL, nR: tick increments since last call (integers)
  // rs_valid: se la misura realsense è valida
  void step(double t_now,
            double imu_accel_x,
            double imu_gyro_z,
            int nL, int nR,
            double rs_x, double rs_y, double rs_theta,
            bool rs_valid)
  {
    if (!initialized_) {
      // initialize with zeros if necessary
      init(0.0, 0.0, 0.0, 0.0, t_now);
    }

    double dt = t_now - t_last_;
    if (!std::isfinite(dt) || dt <= 0.0) dt = 0.0;

    // ---------- Prediction ----------
    double x = x_(0), y = x_(1), th = x_(2), v = x_(3);

    // propagate state (same as MATLAB)
    Eigen::Vector4d x_pred;
    x_pred(0) = x + v * std::cos(th) * dt;
    x_pred(1) = y + v * std::sin(th) * dt;
    x_pred(2) = th + imu_gyro_z * dt; // omega from IMU gyroZ
    x_pred(3) = v + imu_accel_x * dt; // v += a*dt

    // Jacobian F (as in MATLAB)
    Eigen::Matrix4d F;
    F << 1, 0, -v*std::sin(th)*dt, std::cos(th)*dt,
         0, 1,  v*std::cos(th)*dt, std::sin(th)*dt,
         0, 0, 1,                 0,
         0, 0, 0,                 1;

    Eigen::Matrix4d P_pred = F * P_ * F.transpose() + Q_;

    // ---------- Encoder update (velocity) ----------
    if (dt > 0) {
      // wheel angular velocities (rad/s)
      double wL = (2.0*M_PI * static_cast<double>(nL) / static_cast<double>(n0_)) / dt;
      double wR = (2.0*M_PI * static_cast<double>(nR) / static_cast<double>(n0_)) / dt;
      double v_enc = 0.5 * (R_L_ * wL + R_R_ * wR); // linear forward velocity from encoders

      // measurement model z = v (scalar)
      double h = x_pred(3);
      Eigen::RowVector4d H_enc; H_enc << 0, 0, 0, 1;

      double S = (H_enc * P_pred * H_enc.transpose())(0,0) + R_enc_;
      Eigen::Vector4d K = P_pred * H_enc.transpose() / S;

      x_pred = x_pred + K * (v_enc - h);
      P_pred = (Eigen::Matrix4d::Identity() - K * H_enc) * P_pred;
    }
    // else if dt==0 skip encoder update (no new info)

    // ---------- RealSense update (x,y,theta) ----------
    if (rs_valid) {
      Eigen::Vector3d z_rs; z_rs << rs_x, rs_y, rs_theta;
      Eigen::Vector3d h_rs; h_rs << x_pred(0), x_pred(1), x_pred(2);

      Eigen::Matrix<double,3,4> H_rs;
      H_rs << 1,0,0,0,
              0,1,0,0,
              0,0,1,0;

      Eigen::Matrix3d Srs = H_rs * P_pred * H_rs.transpose() + R_rs_;
      Eigen::Matrix<double,4,3> Krs = P_pred * H_rs.transpose() * Srs.inverse();

      Eigen::Vector3d y_res = z_rs - h_rs;
      // normalize angle residual
      y_res(2) = std::atan2(std::sin(y_res(2)), std::cos(y_res(2)));

      x_ = x_pred + Krs * y_res;
      P_ = (Eigen::Matrix4d::Identity() - Krs * H_rs) * P_pred;
    } else {
      // no RS update
      x_ = x_pred;
      P_ = P_pred;
    }

    t_last_ = t_now;
  }

  // getters
  Eigen::Vector4d getState() const { return x_; }
  Eigen::Matrix4d getCovariance() const { return P_; }

private:
  // parameters
  double R_L_, R_R_, b_;
  int n0_;

  bool initialized_;
  double t_last_;

  // EKF internal
  Eigen::Vector4d x_;
  Eigen::Matrix4d P_;
  Eigen::Matrix4d Q_;
  double R_enc_;
  Eigen::Matrix3d R_rs_;
};








// _______________________________________________________________________________________________


// Plugin class. This shall be the only part that needs to be modified,
// implementing the actual functionality
class Pose_estimationPlugin : public Filter<json, json> {

public:

  // Typically, no need to change this
  string kind() override { return PLUGIN_NAME; }

  // Implement the actual functionality here
  return_type load_data(json const &input, string topic = "") override {

    // Store data from encoders
    if (input.contains("message") && input["message"].contains("encoders")) {
      auto &E = input["message"]["encoders"];
      if (E.contains("left") && E["left"].is_number()) {
        encoder_data.left_encoder = E["left"].get<int>();
        if(!second){
          first = true;
        }
      }
      if (E.contains("right") && E["right"].is_number()) {
        encoder_data.right_encoder = E["right"].get<int>();
      }
    }

    // Store data from HTC (position is a vector with x,y,z)
    if (input.contains("message") && input["message"].contains("pose") && input["message"]["pose"].contains("position")) {
      auto &P = input["message"]["pose"]["position"];
      if (P.is_array() && P.size() >= 3) {
        if (P[0].is_number()) {
          htc_data.x = P[0].get<float>();
        }
        if (P[1].is_number()) {
          htc_data.y = P[1].get<float>();
        }
        if (P[2].is_number()) {
          htc_data.z = P[2].get<float>();
        } 
      }
    }

    // Store data from Realsense (position is a vector with x,y,z)
    if (input.contains("message") && input["message"].contains("pose") && input["message"]["pose"].contains("position_rs")) {
      auto &P = input["message"]["pose"]["position_rs"];
      if (P.is_array() && P.size() >= 3) {
        if (P[0].is_number()) {
          realsense_data.x = P[0].get<float>();
        }
        if (P[1].is_number()) {
          realsense_data.y = P[1].get<float>();
        }
        if (P[2].is_number()) {
          realsense_data.z = P[2].get<float>();
        }
      }
      auto &A = input["message"]["pose"]["attitude"];
      if(A.is_array() && A.size() >= 3){
        if (A[2].is_number()){
          realsense_data.theta = A[2].get<float>();
        }
      }
    }

    // Store data from IMU
    if (input.contains("message") && input["message"].contains("fusionPose")) {
      auto &E = input["message"]["fusionPose"];
      if (E.is_array() && E.size() >= 3) {
        if (E[0].is_number()) {
          imu_data.x = E[0].get<float>();
        }
        if (E[1].is_number()) {
          imu_data.y = E[1].get<float>();
        }
        if (E[2].is_number()) {
          imu_data.z = E[2].get<float>();
        } 
      }
      auto &A = input["message"]["accel"];
      if (A.is_array() && A.size() >= 3){
        if (A.is_array() && A.size() >=3){
          if (A[0].is_number()){
            imu_data.acc_x = A[0].get<float>();
          }
          if (A[1].is_number()){
            imu_data.acc_y = A[1].get<float>();
          }
          if (A[2].is_number()){
            imu_data.acc_z = A[2].get<float>();
          }
        }
      }

      auto &G = input["message"]["gyro"];
      if (G.is_array() && G.size() >= 3){
        if (G[0].is_number()){
          imu_data.gyro_x = G[0].get<float>();
        }
        if (G[1].is_number()){
          imu_data.gyro_y = G[1].get<float>();
        }
        if (G[2].is_number()){
          imu_data.gyro_z = G[2].get<float>();
        }
      }
    }
    
    // Store timecode (equal for both sensors)
    if (input.contains("timecode") && input["timecode"].is_number()) {
      encoder_data.timecode = input["timecode"].get<double>();
      htc_data.timecode = input["timecode"].get<double>();
      realsense_data.timecode = input["timecode"].get<double>();
      imu_data.timecode = input["timecode"].get<double>();
    }

    if(PRINT_INPUT){
       // Print the input data for debugging purposes
      cout << "\n\n___________ Input data: ____________\n\n" << input.dump(2) << endl;

      // Debug: print stored data
      cout << "\n\n___________ Stored data: ____________\n\n";
      cout << "Encoders: Left = " << encoder_data.left_encoder
            << ", Right = " << encoder_data.right_encoder << endl;
      cout << "HTC Position: x = " << htc_data.x
            << ", y = " << htc_data.y
            << ", z = " << htc_data.z << endl;
      cout << "Realsense Position: x = " << realsense_data.x
            << ", y = " << realsense_data.y
            << ", z = " << realsense_data.z << endl;
      cout << "IMU Position: x = " << imu_data.x
            << ", y = " << imu_data.y
            << ", z = " << imu_data.z << endl;
      cout << "Timecode: " << encoder_data.timecode << endl;  
    }
    // Do something with the input data
    return return_type::success;
  }

  // We calculate the average of the last N values for each key and store it
  // into the output json object
  return_type process(json &out) override {
  
    if (first) {
      // pose_data_enc.x = -12.86;  // initial x position [m]
      last_enc_L = encoder_data.left_encoder;
      last_enc_R = encoder_data.right_encoder;
      last_time = encoder_data.timecode;
      second = true;
      first = false;
      cout << "First run initialization done." << endl;
    }

    // Compute variation of the encoder ticks: Δtic
    int n_Lk = encoder_data.left_encoder - last_enc_L;
    int n_Rk = encoder_data.right_encoder - last_enc_R;

    // Update last encoder values
    last_enc_L = encoder_data.left_encoder;
    last_enc_R = encoder_data.right_encoder;

    // Compute time difference
    double dt = encoder_data.timecode - last_time;
    if (!std::isfinite(dt) || dt <= 0) dt = 0;

    // Kinematic model (as in MATLAB)
    double dx = M_PI * (n_Rk * R_R + n_Lk * R_L) / n0 * std::cos(pose_data_enc.theta);
    double dy = M_PI * (n_Rk * R_R + n_Lk * R_L) / n0 * std::sin(pose_data_enc.theta);
    double dtheta = 2 * M_PI * (n_Rk * R_R - n_Lk * R_L) / (n0 * b);


    // EKF update
    ExtendedKalmanFilter ekf{ R_L, R_R, b, n0};

    if (ekf_first_init) {
      // inizializza lo stato EKF con lo stato corrente dei pose_data_enc (se vuoi)
      // oppure con zeri: qui inizializzo con pose_data_enc se disponibili
      ekf.init(pose_data_enc.x, pose_data_enc.y, pose_data_enc.theta, 0.0, encoder_data.timecode);
      ekf_first_init = false;
    }

    // chiamata step EKF: dt = encoder_data.timecode - last_time (lo hai già calcolato)
    bool rs_valid = true; // se hai modo di verificare realsense valid, imposta opportunamente

    ekf.step(
      encoder_data.timecode,
      imu_data.acc_x,
      imu_data.gyro_z,
      n_Lk,
      n_Rk,
      realsense_data.x,
      realsense_data.y,
      realsense_data.theta,
      rs_valid
    );

    // ________ UPDATE POSE ________ 

    // Update pose from encoder
    pose_data_enc.x += dx;
    pose_data_enc.y += dy;
    pose_data_enc.z = 0.0;          // assuming z=0 for encoders
    pose_data_enc.theta += dtheta;
    pose_data_enc.timecode = encoder_data.timecode;

    // Pose data from htc
    pose_data_htc.x = htc_data.x;
    pose_data_htc.y = htc_data.y;
    pose_data_htc.z = 0.0;          // assuming z=0 for HTC
    pose_data_htc.timecode = htc_data.timecode;

    // Pose data from realsense
    pose_data_realsense.x = realsense_data.x;
    pose_data_realsense.y = realsense_data.y;
    pose_data_realsense.z = 0.0;    // assuming z=0 for realsense
    pose_data_realsense.timecode = realsense_data.timecode;

    // Pose data from imu
    pose_data_imu.x = imu_data.x;
    pose_data_imu.y = imu_data.y;
    pose_data_imu.z = 0.0;          // assuming z=0 for imu
    pose_data_imu.timecode = imu_data.timecode;

    // Pose data from EKF
    Eigen::Vector4d xekf = ekf.getState();
    pose_data_ekf.x = xekf(0);
    pose_data_ekf.y = xekf(1);
    pose_data_ekf.z = 0.0;          // assuming z=0 for EKF
    pose_data_ekf.theta = xekf(2);
    pose_data_ekf.timecode = encoder_data.timecode;



    // ________ CONSTRUCT OUTPUT __________ 
    out.clear();
    // output from input data 
    out["encoders"] = {
      {"left", encoder_data.left_encoder},
      {"right", encoder_data.right_encoder}
    };
    out["htc"] = {htc_data.x, htc_data.y, htc_data.z};
    out["realsense"] = {realsense_data.x, realsense_data.y, realsense_data.z};
    out["imu"] = {imu_data.x, imu_data.y, imu_data.z};
    // output from data elaboration
    out["position_enc"] = {pose_data_enc.x, pose_data_enc.y, pose_data_enc.z};
    out["position_htc"] = {pose_data_htc.x, pose_data_htc.y, pose_data_htc.z};
    out["position_realsense"] = {pose_data_realsense.x, pose_data_realsense.y, pose_data_realsense.z};
    out["position_imu"] = {pose_data_imu.x, pose_data_imu.y, pose_data_imu.z};
    out["position_ekf"] = {pose_data_ekf.x, pose_data_ekf.y, pose_data_ekf.z};
    out["attitude_ekf"] = pose_data_ekf.theta;
    out["velocity_ekf"] = xekf(3);


    // _______ PRINT FOR DEBUG ___________
    if (PRINT_OUTPUT){
      cout << "\n\n___________ Output data: ____________\n\n" << out.dump(2) << endl;
      cout << "\n\n___________ Computed Pose Data: ____________\n\n";
      cout << "Encoder-based Pose: x = " << pose_data_enc.x << ", y = " << pose_data_enc.y << ", z = " << pose_data_enc.z << ", theta = " << pose_data_enc.theta << ", timecode = " << pose_data_enc.timecode << endl;
      cout << "HTC Pose: x = " << pose_data_htc.x << ", y = " << pose_data_htc.y << ", z = " << pose_data_htc.z << ", theta = " << pose_data_htc.theta << ", timecode = " << pose_data_htc.timecode << endl;
      cout << "Realsense Pose: x = " << pose_data_realsense.x << ", y = " << pose_data_realsense.y << ", z = " << pose_data_realsense.z << ", theta = " << pose_data_realsense.theta << ", timecode = " << pose_data_realsense.timecode << endl;
      cout << "IMU Pose: x = " << pose_data_imu.x << ", y = " << pose_data_imu.y << ", z = " << pose_data_imu.z << ", theta = " << pose_data_imu.theta << ", timecode = " << pose_data_imu.timecode << endl;
      cout << "Time difference dt = " << dt << " seconds" << endl;
      cout << "dx = " << dx << ", dy = " << dy << ", dtheta = " << dtheta << endl;
    }
    return return_type::success;
  }
  
  void set_params(void const *params) override {
    // Call the parent class method to set the common parameters 
    // (e.g. agent_id, etc.)
    Filter::set_params(params);
    
    R_L = _params["R_L"];
    R_R = _params["R_R"];
    n0 = _params["n0"];
    b = _params["b"];

    // then merge the defaults with the actually provided parameters params needs to be cast to json
    _params.merge_patch(*(json *)params);
  }

  // Implement this method if you want to provide additional information
  map<string, string> info() override { 
    // return a map of strings with additional information about the plugin
    // it is used to print the information about the plugin when it is loaded
    // by the agent
    
    return {};
    
  };

private:
  // kinematic parameters
  double R_L;       // raggio ruota sinistra [m]
  double R_R;       // raggio ruota destra [m]
  int n0;        // tics per giro
  double b;         // distanza tra ruote [m]

  // Data in input from sensors
  EncoderData encoder_data;
  HTCData htc_data;
  RealsenseData realsense_data;
  IMUData imu_data;

  // Position computed by filter
  PoseData pose_data_enc;
  PoseData pose_data_htc;
  PoseData pose_data_realsense;
  PoseData pose_data_imu;
  PoseData pose_data_ekf;
};


/*
  ____  _             _             _      _
 |  _ \| |_   _  __ _(_)_ __     __| |_ __(_)_   _____ _ __
 | |_) | | | | |/ _` | | '_ \   / _` | '__| \ \ / / _ \ '__|
 |  __/| | |_| | (_| | | | | | | (_| | |  | |\ V /  __/ |
 |_|   |_|\__,_|\__, |_|_| |_|  \__,_|_|  |_| \_/ \___|_|
                |___/
Enable the class as plugin
*/
INSTALL_FILTER_DRIVER(Pose_estimationPlugin, json, json);


/*
                  _       
  _ __ ___   __ _(_)_ __  
 | '_ ` _ \ / _` | | '_ \ 
 | | | | | | (_| | | | | |
 |_| |_| |_|\__,_|_|_| |_|
                          
*/

int main(int argc, char const *argv[])
{
  Pose_estimationPlugin plugin;
  json params;
  json input, output;

  // Set example values to params
  params["test"] = "value";


  // Set the parameters
  plugin.set_params(&params);

  // Set input data
  input["data"] = {
    {"AX", 1},
    {"AY", 2},
    {"AZ", 3}
  };

  // Set input data
  plugin.load_data(input);
  cout << "Input: " << input.dump(2) << endl;

  // Process data
  plugin.process(output);
  cout << "Output: " << output.dump(2) << endl;


  return 0;
}

